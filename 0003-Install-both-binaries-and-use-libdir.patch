From e690915a96b568f6550563491a346aacd8b717a5 Mon Sep 17 00:00:00 2001
From: Elliott Sales de Andrade <quantum.analyst@gmail.com>
Date: Tue, 19 Mar 2019 23:22:40 -0400
Subject: [PATCH 3/3] Install both binaries and use libdir.

This allows us to build with a shared library for other users while
still providing the normal executable.

Signed-off-by: Elliott Sales de Andrade <quantum.analyst@gmail.com>
---
 configure.py     |  7 +++++++
 tools/install.py | 29 +++++++++++++----------------
 2 files changed, 20 insertions(+), 16 deletions(-)

diff --git a/configure.py b/configure.py
index 15ea5687cf1cd8e4ebe449ea2fc39eea95fb29b6..a738e300d6098bef4975930422b3fa55b3f5421d 100755
--- a/configure.py
+++ b/configure.py
@@ -534,10 +534,16 @@ parser.add_option('--shared',
     action='store_true',
     dest='shared',
     help='compile shared library for embedding node in another project. ' +
          '(This mode is not officially supported for regular applications)')
 
+parser.add_option('--libdir',
+    action='store',
+    dest='libdir',
+    default='lib',
+    help='a directory to install the shared library into')
+
 parser.add_option('--without-v8-platform',
     action='store_true',
     dest='without_v8_platform',
     default=False,
     help='do not initialize v8 platform during node.js startup. ' +
@@ -1065,10 +1071,11 @@ def configure_node(o):
   o['variables']['node_no_browser_globals'] = b(options.no_browser_globals)
   # TODO(refack): fix this when implementing embedded code-cache when cross-compiling.
   if o['variables']['want_separate_host_toolset'] == 0:
     o['variables']['node_code_cache_path'] = 'yes'
   o['variables']['node_shared'] = b(options.shared)
+  o['variables']['libdir'] = options.libdir
   node_module_version = getmoduleversion.get_version()
 
   if sys.platform == 'darwin':
     shlib_suffix = '%s.dylib'
   elif sys.platform.startswith('aix'):
diff --git a/tools/install.py b/tools/install.py
index 655802980a6ea94d1d4ca1dc63c8c8e905fbb83a..fe4723bf15012c8aacacb0393dc8294c049b0503 100755
--- a/tools/install.py
+++ b/tools/install.py
@@ -119,30 +119,27 @@ def subdir_files(path, dest, action):
   for subdir, files_in_path in ret.items():
     action(files_in_path, subdir + '/')
 
 def files(action):
   is_windows = sys.platform == 'win32'
-  output_file = 'node'
   output_prefix = 'out/Release/'
+  output_libprefix = output_prefix
 
-  if 'false' == variables.get('node_shared'):
-    if is_windows:
-      output_file += '.exe'
+  if is_windows:
+    output_bin = 'node.exe'
+    output_lib = 'node.dll'
   else:
-    if is_windows:
-      output_file += '.dll'
-    else:
-      output_file = 'lib' + output_file + '.' + variables.get('shlib_suffix')
-      # GYP will output to lib.target except on OS X, this is hardcoded
-      # in its source - see the _InstallableTargetInstallPath function.
-      if sys.platform != 'darwin':
-        output_prefix += 'lib.target/'
+    output_bin = 'node'
+    output_lib = 'libnode.' + variables.get('shlib_suffix')
+    # GYP will output to lib.target except on OS X, this is hardcoded
+    # in its source - see the _InstallableTargetInstallPath function.
+    if sys.platform != 'darwin':
+      output_libprefix += 'lib.target/'
 
-  if 'false' == variables.get('node_shared'):
-    action([output_prefix + output_file], 'bin/' + output_file)
-  else:
-    action([output_prefix + output_file], 'lib/' + output_file)
+  action([output_prefix + output_bin], 'bin/' + output_bin)
+  if 'true' == variables.get('node_shared'):
+    action([output_libprefix + output_lib], variables.get('libdir') + '/' + output_lib)
 
   if 'true' == variables.get('node_use_dtrace'):
     action(['out/Release/node.d'], 'lib/dtrace/node.d')
 
   # behave similarly for systemtap
-- 
2.21.0

